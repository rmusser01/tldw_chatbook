# test_embeddings_properties.py
# Property-based tests for the embeddings service using hypothesis

import pytest
import tempfile
from pathlib import Path
import shutil
from unittest.mock import patch, MagicMock
from hypothesis import given, strategies as st, assume, settings, HealthCheck
from hypothesis.stateful import RuleBasedStateMachine, rule, invariant, Bundle
import string

from tldw_chatbook.RAG_Search.Services.embeddings_service import EmbeddingsService


@pytest.mark.requires_rag_deps
class TestEmbeddingsProperties:
    """Property-based tests for embeddings service"""
    
    @pytest.fixture
    def temp_dir(self):
        """Create a temporary directory for ChromaDB"""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir)
        shutil.rmtree(temp_dir)
    
    @pytest.fixture
    def mock_cache_service(self):
        """Create a deterministic mock cache service"""
        mock = MagicMock()
        
        # Use a deterministic cache based on text hash
        def get_embeddings_batch(texts):
            cached = {}
            uncached = []
            for text in texts:
                # Cache texts with even hash
                if hash(text) % 2 == 0:
                    # Generate deterministic embedding
                    hash_val = abs(hash(text))
                    cached[text] = [
                        (hash_val % 1000) / 1000.0,
                        (hash_val % 997) / 1000.0
                    ]
                else:
                    uncached.append(text)
            return cached, uncached
        
        mock.get_embeddings_batch.side_effect = get_embeddings_batch
        mock.cache_embeddings_batch.return_value = None
        
        return mock
    
    @pytest.fixture
    @patch('tldw_chatbook.RAG_Search.Services.embeddings_service.CHROMADB_AVAILABLE', True)
    @patch('tldw_chatbook.RAG_Search.Services.embeddings_service.EMBEDDINGS_AVAILABLE', True)
    @patch('tldw_chatbook.RAG_Search.Services.embeddings_service.chromadb')
    @patch('tldw_chatbook.RAG_Search.Services.embeddings_service.get_cache_service')
    def property_embeddings_service(self, mock_get_cache, mock_chromadb, mock_cache_service, temp_dir):
        """Create embeddings service for property testing"""
        # Mock ChromaDB client
        mock_client = MagicMock()
        mock_chromadb.PersistentClient.return_value = mock_client
        
        # Use mock cache service
        mock_get_cache.return_value = mock_cache_service
        
        service = EmbeddingsService(temp_dir)
        service.client = mock_client
        
        # Mock embedding model with deterministic output
        mock_model = MagicMock()
        
        def deterministic_encode(texts):
            mock_array = MagicMock()
            embeddings = []
            for text in texts:
                # Generate deterministic embedding based on text
                hash_val = abs(hash(text))
                embeddings.append([
                    (hash_val % 1000) / 1000.0,
                    (hash_val % 997) / 1000.0
                ])
            mock_array.tolist.return_value = embeddings
            return mock_array
        
        mock_model.encode.side_effect = deterministic_encode
        service.embedding_model = mock_model
        
        return service
    
    @given(texts=st.lists(st.text(min_size=1, max_size=100), min_size=1, max_size=50))
    @settings(suppress_health_check=[HealthCheck.function_scoped_fixture])
    def test_embedding_dimensions_consistency(self, property_embeddings_service, texts):
        """Property: All embeddings should have consistent dimensions"""
        embeddings = property_embeddings_service.create_embeddings(texts)
        
        if embeddings:
            # All embeddings should have the same dimension
            first_dim = len(embeddings[0])
            assert all(len(emb) == first_dim for emb in embeddings)
            
            # Should match the number of input texts
            assert len(embeddings) == len(texts)
    
    @given(texts=st.lists(st.text(min_size=1), min_size=1, max_size=20))
    def test_embedding_determinism(self, property_embeddings_service, texts):
        """Property: Same texts should produce same embeddings"""
        # Get embeddings twice
        embeddings1 = property_embeddings_service.create_embeddings(texts)
        embeddings2 = property_embeddings_service.create_embeddings(texts)
        
        if embeddings1 and embeddings2:
            # Should be identical
            assert embeddings1 == embeddings2
    
    @given(
        texts=st.lists(st.text(min_size=1), min_size=1, max_size=10),
        permutation=st.permutations(range(10))
    )
    def test_embedding_order_independence(self, property_embeddings_service, texts, permutation):
        """Property: Order of texts shouldn't affect individual embeddings"""
        # Limit permutation to text length
        perm_indices = [i for i in permutation[:len(texts)] if i < len(texts)]
        assume(len(perm_indices) == len(texts))  # Ensure valid permutation
        
        # Create permuted texts
        permuted_texts = [texts[i] for i in perm_indices]
        
        # Get embeddings for both orders
        embeddings_original = property_embeddings_service.create_embeddings(texts)
        embeddings_permuted = property_embeddings_service.create_embeddings(permuted_texts)
        
        if embeddings_original and embeddings_permuted:
            # Each text should have the same embedding regardless of order
            for i, perm_idx in enumerate(perm_indices):
                assert embeddings_original[perm_idx] == embeddings_permuted[i]
    
    @given(
        collection_name=st.text(
            alphabet=string.ascii_letters + string.digits + "_",
            min_size=1,
            max_size=50
        ),
        num_docs=st.integers(min_value=1, max_value=20)
    )
    def test_collection_document_count_invariant(self, property_embeddings_service, collection_name, num_docs):
        """Property: Collection document count should match added documents"""
        # Create mock collection
        mock_collection = MagicMock()
        mock_collection.count.return_value = 0
        added_count = 0
        
        def mock_add(**kwargs):
            nonlocal added_count
            added_count += len(kwargs['documents'])
            mock_collection.count.return_value = added_count
        
        mock_collection.add.side_effect = mock_add
        property_embeddings_service.client.get_or_create_collection.return_value = mock_collection
        
        # Add documents
        documents = [f"doc_{i}" for i in range(num_docs)]
        embeddings = [[float(i)/100, float(i)/200] for i in range(num_docs)]
        metadatas = [{"id": i} for i in range(num_docs)]
        ids = [f"id_{i}" for i in range(num_docs)]
        
        success = property_embeddings_service.add_documents_to_collection(
            collection_name,
            documents,
            embeddings,
            metadatas,
            ids
        )
        
        if success:
            # Get collection info
            info = property_embeddings_service.get_collection_info(collection_name)
            assert info['count'] == num_docs
    
    @given(
        texts=st.lists(st.text(min_size=1), min_size=1, max_size=30),
        batch_size=st.integers(min_value=1, max_value=50)
    )
    def test_batch_processing_completeness(self, property_embeddings_service, texts, batch_size):
        """Property: Batch processing should process all texts exactly once"""
        property_embeddings_service.batch_size = batch_size
        
        # Track which texts were processed
        processed_texts = []
        
        original_encode = property_embeddings_service.embedding_model.encode.side_effect
        
        def tracking_encode(batch_texts):
            processed_texts.extend(batch_texts)
            return original_encode(batch_texts)
        
        property_embeddings_service.embedding_model.encode.side_effect = tracking_encode
        
        # Process texts
        embeddings = property_embeddings_service.create_embeddings(texts)
        
        if embeddings:
            # All texts should be processed exactly once
            # Note: Due to caching, some texts might not go through encode
            assert len(embeddings) == len(texts)
    
    @given(
        max_workers=st.integers(min_value=1, max_value=16),
        batch_size=st.integers(min_value=1, max_value=100),
        enable_parallel=st.booleans()
    )
    def test_configuration_bounds(self, property_embeddings_service, max_workers, batch_size, enable_parallel):
        """Property: Configuration should accept and store valid values"""
        property_embeddings_service.configure_performance(
            max_workers=max_workers,
            batch_size=batch_size,
            enable_parallel=enable_parallel
        )
        
        assert property_embeddings_service.max_workers == max_workers
        assert property_embeddings_service.batch_size == batch_size
        assert property_embeddings_service.enable_parallel_processing == enable_parallel
    
    @given(texts=st.lists(
        st.text(alphabet=st.characters(blacklist_categories=['Cs', 'Cc']), min_size=1),
        min_size=1,
        max_size=10
    ))
    def test_unicode_text_handling(self, property_embeddings_service, texts):
        """Property: Should handle unicode texts correctly"""
        embeddings = property_embeddings_service.create_embeddings(texts)
        
        if embeddings:
            assert len(embeddings) == len(texts)
            # All embeddings should be valid
            assert all(isinstance(emb, list) and len(emb) == 2 for emb in embeddings)
    
    @given(
        texts=st.lists(st.text(min_size=1), min_size=1, max_size=10),
        n_results=st.integers(min_value=1, max_value=100)
    )
    def test_search_results_bounds(self, property_embeddings_service, texts, n_results):
        """Property: Search should never return more results than requested"""
        # Create collection and add documents
        mock_collection = MagicMock()
        
        # Mock search to return at most n_results
        def mock_query(**kwargs):
            requested = kwargs.get('n_results', 10)
            actual_results = min(requested, len(texts))
            return {
                'documents': [[f"doc_{i}" for i in range(actual_results)]],
                'distances': [[0.1 * i for i in range(actual_results)]],
                'metadatas': [[{"id": i} for i in range(actual_results)]]
            }
        
        mock_collection.query.side_effect = mock_query
        property_embeddings_service.client.get_or_create_collection.return_value = mock_collection
        
        # Search
        query_embedding = [[0.5, 0.5]]
        results = property_embeddings_service.search_collection(
            "test_collection",
            query_embedding,
            n_results=n_results
        )
        
        if results:
            # Should never return more than requested
            assert len(results['documents'][0]) <= n_results
            # Should never return more than available
            assert len(results['documents'][0]) <= len(texts)


class EmbeddingsStateMachine(RuleBasedStateMachine):
    """Stateful testing for embeddings service using hypothesis"""
    
    def __init__(self):
        super().__init__()
        self.temp_dir = Path(tempfile.mkdtemp())
        
        # Set up mocks
        with patch('tldw_chatbook.RAG_Search.Services.embeddings_service.CHROMADB_AVAILABLE', True):
            with patch('tldw_chatbook.RAG_Search.Services.embeddings_service.EMBEDDINGS_AVAILABLE', True):
                with patch('tldw_chatbook.RAG_Search.Services.embeddings_service.chromadb') as mock_chromadb:
                    with patch('tldw_chatbook.RAG_Search.Services.embeddings_service.get_cache_service') as mock_get_cache:
                        
                        # Mock setup
                        mock_client = MagicMock()
                        mock_chromadb.PersistentClient.return_value = mock_client
                        
                        mock_cache = MagicMock()
                        mock_cache.get_embeddings_batch.return_value = ({}, [])
                        mock_cache.cache_embeddings_batch.return_value = None
                        mock_get_cache.return_value = mock_cache
                        
                        self.service = EmbeddingsService(self.temp_dir)
                        self.service.client = mock_client
                        
                        # Mock embedding model
                        mock_model = MagicMock()
                        mock_model.encode.side_effect = self._mock_encode
                        self.service.embedding_model = mock_model
        
        # State tracking
        self.collections = {}
        self.embeddings_created = 0
        self.documents_added = {}
    
    def _mock_encode(self, texts):
        """Mock encode function"""
        mock_array = MagicMock()
        embeddings = [[0.1, 0.2] for _ in texts]
        mock_array.tolist.return_value = embeddings
        self.embeddings_created += len(texts)
        return mock_array
    
    def teardown(self):
        """Clean up after test"""
        shutil.rmtree(self.temp_dir)
    
    # Bundles for generated data
    texts = Bundle('texts')
    collection_names = Bundle('collection_names')
    
    @rule(texts=st.lists(st.text(min_size=1), min_size=1, max_size=10))
    def create_embeddings(self, texts):
        """Create embeddings for texts"""
        embeddings = self.service.create_embeddings(texts)
        assert embeddings is not None
        assert len(embeddings) == len(texts)
        return texts
    
    @rule(
        target=collection_names,
        name=st.text(alphabet=string.ascii_letters + string.digits, min_size=1, max_size=20)
    )
    def create_collection(self, name):
        """Create a new collection"""
        collection = self.service.get_or_create_collection(name)
        if collection:
            self.collections[name] = {
                'count': 0,
                'documents': []
            }
        return name
    
    @rule(
        collection=collection_names,
        num_docs=st.integers(min_value=1, max_value=10)
    )
    def add_documents(self, collection, num_docs):
        """Add documents to a collection"""
        if collection not in self.collections:
            return
        
        documents = [f"doc_{i}" for i in range(num_docs)]
        embeddings = [[0.1, 0.2] for _ in range(num_docs)]
        metadatas = [{"id": i} for i in range(num_docs)]
        ids = [f"{collection}_doc_{self.collections[collection]['count'] + i}" for i in range(num_docs)]
        
        # Mock the collection
        mock_collection = MagicMock()
        self.service.client.get_or_create_collection.return_value = mock_collection
        
        success = self.service.add_documents_to_collection(
            collection,
            documents,
            embeddings,
            metadatas,
            ids
        )
        
        if success:
            self.collections[collection]['count'] += num_docs
            self.collections[collection]['documents'].extend(ids)
            self.documents_added[collection] = self.documents_added.get(collection, 0) + num_docs
    
    @rule(collection=collection_names)
    def search_collection(self, collection):
        """Search a collection"""
        if collection not in self.collections:
            return
        
        results = self.service.search_collection(
            collection,
            [[0.5, 0.5]],
            n_results=10
        )
        
        # Results should be valid if returned
        if results:
            assert 'documents' in results
            assert 'distances' in results
    
    @invariant()
    def embeddings_count_increases(self):
        """Embeddings created count should never decrease"""
        assert self.embeddings_created >= 0
    
    @invariant()
    def collections_have_valid_counts(self):
        """Collection counts should be non-negative"""
        for collection, data in self.collections.items():
            assert data['count'] >= 0
            assert data['count'] == len(data['documents'])
    
    @invariant()
    def documents_added_matches_collections(self):
        """Documents added should match collection state"""
        for collection, count in self.documents_added.items():
            if collection in self.collections:
                assert count == self.collections[collection]['count']


# Run the state machine test
TestEmbeddingsStateMachine = EmbeddingsStateMachine.TestCase